In this part we'll deliver a message to multiple consumers. This pattern is known as "publish/subscribe".

## Exchanges

- A producer is a user application that sends messages.
- A queue is a buffer that stores messages.
- A consumer is a user application that receives messages.

**The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue.**
Actually, quite often the producer doesn't even know if a message will be delivered to any queue at all.

Instead, the producer can only send messages to an exchange. An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives. Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. The rules for that are defined by the exchange type.

There are a few exchange types available: `direct`, `topic`, `headers` and `fanout`. We'll focus on the last one -- the `fanout`. Let's create an exchange of this type, and call it logs:

```go
err = ch.ExchangeDeclare(
  "logs",   // name
  "fanout", // type
  true,     // durable
  false,    // auto-deleted
  false,    // internal
  false,    // no-wait
  nil,      // arguments
)
```

The fanout exchange is very simple. As you can probably guess from the name, it just broadcasts all the messages it receives to all the queues it knows. And that's exactly what we need for our logger.

> The default exchange
> In previous parts of the tutorial we knew nothing about exchanges, but still were able to send messages to queues. That was possible because we were using a default exchange, which is identified by the empty string ("").
> The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.
>
> Recall how we published a message before:
>
> ```go
> err = ch.PublishWithContext(ctx,
>   "",     // exchange
>   q.Name, // routing key
>   false,  // mandatory
>   false,  // immediate
>   amqp.Publishing{
>     ContentType: "text/plain",
>     Body:        []byte(body),
> })
> ```
>
> Here we use the default or nameless exchange: messages are routed to the queue with the name specified by routing_key parameter, if it exists.

```go
err = ch.ExchangeDeclare(
  "logs",   // name
  "fanout", // type
  true,     // durable
  false,    // auto-deleted
  false,    // internal
  false,    // no-wait
  nil,      // arguments
)
failOnError(err, "Failed to declare an exchange")

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

body := bodyFrom(os.Args)
err = ch.PublishWithContext(ctx,
  "logs", // exchange
  "",     // routing key
  false,  // mandatory
  false,  // immediate
  amqp.Publishing{
          ContentType: "text/plain",
          Body:        []byte(body),
  })
```

## Temporary queues

As you may remember previously we were using queues that had specific names (remember `hello` and `task_queue`?). Being able to name a queue was crucial for us -- we needed to point the workers to the same queue. Giving a queue a name is important when you want to share the queue between producers and consumers.

But that's not the case for our logger. We want to hear about all log messages, not just a subset of them. We're also interested only in currently flowing messages not in the old ones. To solve that we need two things.

Firstly, whenever we connect to Rabbit we need a fresh, empty queue. To do this we could create a queue with a random name, or, even better - let the server choose a random queue name for us.

Secondly, once we disconnect the consumer the queue should be automatically deleted.

In the amqp client, when we supply queue name as an empty string, we create a non-durable queue with a generated name:

```go
// create a non-durable queue with generated name
q, err := ch.QueueDeclare(
  "",    // name
  false, // durable: the queue will survive a broker restart
  false, // delete when unused: queue that has had at least one consumer is deleted when last consumer unsubscribes
  true,  // exclusive: used by only one connection and the queue will be deleted when that connection closes
  false, // no-wait
  nil,   // arguments
)
// the queue instance contains a random queue name generated by RabbitMQ
```

When the method returns, the queue instance contains a random queue name generated by RabbitMQ. For example it may look like `amq.gen-JzTY20BRgKO-HjmUJj0wLg`.

When the connection that declared it closes, the queue will be deleted because it is declared as exclusive.

## Bindings

We've already created a fanout exchange and a queue. Now we need to tell the exchange to send messages to our queue. **That relationship between exchange and a queue is called a binding**.

```go
err = ch.QueueBind(
  q.Name, // queue name
  "",     // routing key
  "logs", // exchange
  false,
  nil,
)
```
